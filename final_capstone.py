# -*- coding: utf-8 -*-
"""Final Capstone.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y1av8QNA_3R6KHj-37gKynyoIL4RAan3

# **Talking Data Mobile User Demographics**

The purpose of this product is to classify population depending on their uses of their phone and phone brands. This classification is the first step to tailor advertising campaigns by third parties based on the usage of the mobile according to the age and gender of the population. For this we have a sample of the population using Mobile Talk data in China. Although this product has been developed for the Chinese population, it can be used globally as further research has shown that other mobile operators in other countries have access to the same type of data.

The purpose of this task is to build a model predicting users’ demographic characteristics based on their app usage, geolocation, and mobile device properties. Doing so will help millions of developers and brand advertisers around the world pursue data-driven marketing efforts which are relevant to their users and catered to their preferences.

**Target: gender_age group (M18_25, M26_35, M36_42, etc., F18_25, F26_35, etc.)**

Dataset Link : https://www.kaggle.com/c/talkingdata-mobile-user-demographics

![image.png](data:image/png;base64,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)

As part of this capstone, we are going to perform below models

Deep Learning Models:

*   Artificial Neural Network(ANN)
*   Convolutional Neural Network (CNN)

Supervised Models: (based on Kbest and PCA feature Selection approach)

*   Logistic Classification
*   KNN Classification
*   Decision Tree
*   Support Vector Classification
*   Random Forest

UnSupervised Models:

*   KMeans Clustering with PCA feature selection
*   GMM Clustering with t-SNE feature selection

# **1.Data Load**
"""

#Importing the libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sqlalchemy import create_engine
import statsmodels.api as sm
import matplotlib.pyplot as plt
from keras.layers import SimpleRNN, Dense
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score,KFold, cross_val_predict, GridSearchCV, StratifiedKFold
from statsmodels.tools.eval_measures import mse, rmse
from sklearn.linear_model import LinearRegression, LassoCV, RidgeCV, ElasticNetCV
from sklearn.feature_selection import chi2, f_regression, SelectKBest
from sklearn.metrics import f1_score, accuracy_score, confusion_matrix, mean_absolute_error, classification_report
from sklearn import preprocessing, svm
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.decomposition import PCA
from google.colab import drive
from sklearn.cluster import KMeans
from sklearn import metrics
from tensorflow.keras.datasets import mnist
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

kf = KFold(5)

import warnings
warnings.filterwarnings('ignore')

from google.colab import drive

drive.mount('/content/drive')

#Loading all the datasets
gatrain = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/gender_age_train.csv")
gatest = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/gender_age_test.csv")
phone = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/phone_brand_device_model.csv")
app_events = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/app_events.csv")
app_labels = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/app_labels.csv")
labels_categories = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/label_categories.csv")
events = pd.read_csv("/content/drive/MyDrive/Thinkful - Datascience/events.csv")

"""# **2.Exploratory Data Analysis (EDA)**"""

#Removing the duplicates
phone = phone.drop_duplicates('device_id',keep='first')

"""Checking the samples of all datasets"""

#gatrain dataset sample
print ("gatrain dataset")
gatrain.head()

#gatest dataset sample
print ("gatest dataset")
gatest.head()

#phone dataset sample
print ("phone dataset")
phone.head()

#app events dataset sample
print("app_events dataset")
app_events.head()

#app labels dataset sample
print("app_labels dataset")
app_labels.head()

#events dataset sample
print("events dataset")
events.head()

#Merge the app_events and events to acorss app_ids.
device_apps = (

     app_events

     # Merge on event_id
    .merge(events, how = 'left', left_on = 'event_id', right_on = 'event_id')

     # remove the event_id
    .drop('event_id', axis = 1)

     # Because the events correspond to more than just
     # being installed, there are many duplicates
    .drop_duplicates())
device_apps.head()

#Merge the device_apps and app_lables to acorss app_ids.
apps = (
    device_apps

     # Merge on event_id
    .merge(app_labels, how = 'left', left_on = 'app_id', right_on = 'app_id')

     # remove app_id
    .drop('app_id', axis = 1)

     # Because the events correspond to more than just
     # being installed, there are many duplicates
    .drop_duplicates())

#drop 'na' values
apps.dropna()
#convert first or second to str or int
apps['device_id'] = apps['device_id'].astype(int)

#Merge the column back into the dataset
gatrain['device_id'] = gatrain['device_id'].astype(int)
apps.head()

#cheking the dataset type
apps.info()

#Merge the apps and gatrain to acorss device_ids.
apps_with_groups = (
    apps

     # Merge on event_id
    .merge(gatrain, how = 'left', on = 'device_id')

     #.drop('device_id', axis = 1)

     # Because the events correspond to more than just
     # being installed, there are many duplicates
    .drop_duplicates())

#dropping 'na' values and resetting the index
apps_with_groups = apps_with_groups.dropna()
apps_with_groups.reset_index(drop= True)
apps_with_groups.head()

#Plot installed vs active apps

plt.figure(figsize=(10, 5))
sns.set_style("white")
ax = sns.countplot(x="is_active", data=apps_with_groups, palette="Set3")
ax.set_title('Active vs Installed Apps')
ax.set_ylabel('Number of Occurrences')
ax.set_xticklabels(['Installed','Active'], fontsize=10)
plt.tight_layout()
plt.show()

#Plot the distribution of age in the dataset

plt.figure(figsize=(20, 9))
apps_with_groups.age.hist(bins=50, grid = False)
plt.title('Age Distribution of the Sample')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.tight_layout()
plt.show()

#Plot grouping the apps in different bins to understand its usage.
#Bins range from 10-50 for more detailed analysis

plt.figure(figsize=(20, 9))
apps_with_groups.label_id.value_counts(bins = 50).plot(kind='bar', grid=False)
plt.title('Apps grouped by usage')
plt.xlabel('Group of Apps')
plt.ylabel('Occurrences')
plt.tight_layout()
plt.show()

#Create dummy variables for the categories found in the apps
dataset_with_dummy_variables = pd.get_dummies(apps_with_groups, columns = ['label_id'], sparse = True).reset_index(drop= True)

#Print the first 5 rows of data
dataset_with_dummy_variables.head()

#Add a brand name "UBXX" per brand in Chinese for which we don´t have a translation
english_phone_brands_mapping = {"三星": "samsung","天语": "Ktouch", "海信": "hisense", "联想": "lenovo", "欧比": "obi",
                                "爱派尔": "ipair", "努比亚": "nubia", "优米": "youmi", "朵唯": "dowe", "黑米": "heymi",
                                "锤子": "hammer", "酷比魔方": "koobee", "美图": "meitu", "尼比鲁": "nibilu", "一加": "oneplus",
                                "优购": "yougo", "诺基亚": "nokia", "糖葫芦": "candy", "中国移动": "ccmc", "语信": "yuxin",
                                "基伍": "kiwu", "青橙": "greeno", "华硕": "asus", "夏新": "panasonic", "维图": "weitu",
                                "艾优尼": "aiyouni", "摩托罗拉": "moto", "乡米": "xiangmi", "米奇": "micky", "大可乐": "bigcola",
                                "沃普丰": "wpf", "神舟": "hasse", "摩乐": "mole", "飞秒": "fs", "米歌": "mige", "富可视": "fks",
                                "德赛": "desci", "梦米": "mengmi", "乐视": "lshi", "小杨树": "smallt", "纽曼": "newman",
                                "邦华": "banghua", "E派": "epai", "易派": "epai", "普耐尔": "pner", "欧新": "ouxin", "西米": "ximi",
                                "海尔": "haier", "波导": "bodao", "糯米": "nuomi", "唯米": "weimi", "酷珀": "kupo", "谷歌": "google",
                                "昂达": "ada", "聆韵": "lingyun", "小米": "Xiaomi", "华为": "Huawei", "魅族": "Meizu", "中兴": "ZTE",
                                "酷派": "Coolpad", "金立": "Gionee", "SUGAR": "SUGAR", "OPPO": "OPPO", "vivo": "vivo", "HTC": "HTC",
                                "LG": "LG", "ZUK": "ZUK", "TCL": "TCL", "LOGO": "LOGO", "SUGAR": "SUGAR", "Lovme": "Lovme",
                                "PPTV": "PPTV", "ZOYE": "ZOYE", "MIL": "MIL", "索尼" : "Sony", "欧博信" : "Opssom", "奇酷" : "Qiku",
                                "酷比" : "CUBE", "康佳" : "Konka", "亿通" : "Yitong", "金星数码" : "JXD", "至尊宝" : "Monkey King",
                                "百立丰" : "Hundred Li Feng", "贝尔丰" : "Bifer", "百加" : "Bacardi", "诺亚信" : "Noain",
                                "广信" : "Kingsun", "世纪天元" : "Ctyon", "青葱" : "Cong", "果米" : "Taobao", "斐讯" : "Phicomm",
                                "长虹" : "Changhong", "欧奇" : "Oukimobile", "先锋" : "XFPLAY", "台电" : "Teclast", "大Q" : "Daq",
                                "蓝魔" : "Ramos", "奥克斯" : "AUX", "索尼" : "Sony", "欧博信" : "Opssom", "奇酷" : "Qiku",
                                "酷比" : "CUBE", "康佳" : "Konka", "亿通" : "Yitong", "金星数码" : "JXD", "至尊宝" : "Monkey King",
                                "百立丰" : "Hundred Li Feng", "贝尔丰" : "Bifer", "百加" : "Bacardi", "诺亚信" : "Noain",
                                "广信" : "Kingsun", "世纪天元" : "Ctyon", "青葱" : "Cong", "果米" : "Taobao", "斐讯" : "Phicomm",
                                "长虹" : "Changhong", "欧奇" : "Oukimobile", "先锋" : "XFPLAY", "台电" : "Teclast", "大Q" : "Daq",
                                "蓝魔" : "Ramos", "奥克斯" : "AUX", "飞利浦": "Philips", "智镁": "Zhimei", "惠普": "HP",
                                "原点": "Origin", "戴尔": "Dell", "碟米": "Diemi", "西门子": "Siemens", "亚马逊": "Amazon",
                                "宏碁": "Acer",
                                '世纪星': "UB1", '丰米': "UB2", '优语':'UB3', '凯利通': "UB4", '唯比': "UB5", '嘉源': "UB6",
                                 '大显': "UB7", '天宏时代': "UB8", '宝捷讯': 'UB9','帷幄': 'UB10', '德卡诺': 'UB11',
                                '恒宇丰': 'UB12', '本为': 'UB13', '极米': 'UB14', '欧乐迪': 'UB15', '欧乐酷': 'UB16',
                                '欧沃': 'UB17', '瑞米': 'UB18', '瑞高': 'UB19', '白米': 'UB20', '虾米': 'UB21', '赛博宇华': 'UB22',
                                '首云': 'UB23', '鲜米': 'UB24'}

#Replace the brands in Chinese for the brands in English
phone['phone_brand'].replace(english_phone_brands_mapping, inplace=True)

#Drop the device model column as it is not adding information
phone = phone.drop('device_model',axis=1)

#Retreive information about the new dataset before getting the dummy variables
phone.info()

#Build the dummy variables with the phone brand
phone_dummies = pd.get_dummies(phone, columns = ['phone_brand'], sparse = True).reset_index(drop= True)

#Merge the dataset_with_dummy_variables and phone_dummies to acorss app_ids.
final_dataset = (
    dataset_with_dummy_variables

     # Merge on event_id
    .merge(phone_dummies, how = 'left', left_on = 'device_id', right_on = 'device_id')

     # event_id itself is not interesting
    .fillna(0))

#Information about the dataset
final_dataset.info()

#Drop from the final dataset duplicates for the devices keeping the first one
final_dataset = final_dataset.drop_duplicates('device_id',keep= 'first').reset_index(drop=True)

#Get infomation of the new dataset to see the rows that have been eliminated
print(final_dataset.info())

#Print the first five rows of the dataset
final_dataset.head()

#Visualize the number of answers by Gender and by Category

plt.figure(figsize=(20, 5))
sns.set_style("white")

plt.subplot(1, 2, 1)
ax = sns.countplot(x="gender", data=final_dataset, palette="Set2")
ax.set_title('Classification by Gender')
ax.set_ylabel('Number of Occurrences')
ax.set_xticklabels(['Male','Female'], fontsize=10)
plt.ylim(0, 17500)

plt.subplot(1, 2, 2)
ax = sns.countplot(x="group", data=final_dataset, palette="Set1")
ax.set_title('Classification by Age Range & Gender')
ax.set_ylabel('Number of Occurrences')
ax.set_xticklabels(['M39+','M32-38', 'M29-31', 'M27-28', 'M23-26','M22-','F43+','F33-42', 'F29-32', 'F27-28', 'F24-26', 'F23-'], fontsize=10)
plt.ylim(0, 4000)

plt.tight_layout()
plt.show()

#Count number of datapoints for each group to resample all of them.
print(final_dataset['group'].value_counts())

from sklearn.utils import resample

#Upsample minority classes
# Separate majority and minority classes
final_dataset_majority = final_dataset[final_dataset.group=='M32-38']

#Minorty classes
final_dataset_minority_1 = final_dataset[final_dataset.group=='M39+']
final_dataset_minority_2 = final_dataset[final_dataset.group=='M23-26']
final_dataset_minority_3 = final_dataset[final_dataset.group=='M29-31']
final_dataset_minority_4 = final_dataset[final_dataset.group=='M22-']
final_dataset_minority_5 = final_dataset[final_dataset.group=='F33-42']
final_dataset_minority_6 = final_dataset[final_dataset.group=='M27-28']
final_dataset_minority_7 = final_dataset[final_dataset.group=='F29-32']
final_dataset_minority_8 = final_dataset[final_dataset.group=='F23-']
final_dataset_minority_9 = final_dataset[final_dataset.group=='F43+']
final_dataset_minority_10 = final_dataset[final_dataset.group=='F24-26']
final_dataset_minority_11 = final_dataset[final_dataset.group=='F27-28']


# Upsample airlines minorities
final_dataset_upsampled_1 = resample(final_dataset_minority_1, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_2 = resample(final_dataset_minority_2, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_3 = resample(final_dataset_minority_3, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_4 = resample(final_dataset_minority_4, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_5 = resample(final_dataset_minority_5, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_6 = resample(final_dataset_minority_6, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_7 = resample(final_dataset_minority_7, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_8 = resample(final_dataset_minority_8, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_9 = resample(final_dataset_minority_9, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_10 = resample(final_dataset_minority_10, replace=True, n_samples=3338, random_state=123)
final_dataset_upsampled_11 = resample(final_dataset_minority_11, replace=True, n_samples=3338, random_state=123)

# Combine majority class with upsampled minority classes
final_dataset_upsampled = pd.concat([final_dataset_majority, final_dataset_upsampled_1, final_dataset_upsampled_2,
                                  final_dataset_upsampled_3, final_dataset_upsampled_4, final_dataset_upsampled_5,
                                  final_dataset_upsampled_6, final_dataset_upsampled_7, final_dataset_upsampled_8,
                                  final_dataset_upsampled_9, final_dataset_upsampled_10, final_dataset_upsampled_11])
# Display new class counts
final_dataset_upsampled.group.value_counts()

#Get dummy variables for the gender variable and reset index
clean_final_dataset = pd.get_dummies(final_dataset_upsampled, columns = ['gender'], sparse = True,).reset_index(drop= True)

#Delete column with device_id
clean_final_dataset = clean_final_dataset.drop('device_id', axis = 1)

#Delete columns that are all zeros
clean_final_dataset = clean_final_dataset.drop(clean_final_dataset.columns[(clean_final_dataset == 0).all()], axis = 1)

#Substitute the categorical output variable
clean_final_dataset['group'] = clean_final_dataset['group'].map({'M39+' :0,'M32-38':1, 'M29-31':2, 'M27-28':3, 'M23-26':4,'M22-': 5,
                                           'F43+' :6,'F33-42':7, 'F29-32':8, 'F27-28':9, 'F24-26':10, 'F23-':11 })

#Print the first five rows of the new dataset
clean_final_dataset.head()

#Drop unwanted columns
clean_final_dataset.drop(['is_installed','timestamp','latitude','longitude'],inplace=True,axis=1)

#Print the first five rows of the new dataset
clean_final_dataset.head()

#Defining the X and y
from sklearn.preprocessing import normalize

#Build the predictors and output variables
X = clean_final_dataset.drop('group',axis = 1)
y = clean_final_dataset.group

#Preprocess and scale data
names = X.columns
X_processed = pd.DataFrame(normalize(preprocessing.scale(X)), columns = names)

#Check shape of X_processed and y
print(X_processed.shape, y.shape)

#Print the groups in y
print(y.unique())

#Split the dataset into a training and testing dataset 70/30
X_train, X_test, y_train, y_test = train_test_split(X_processed, y,test_size=0.3, random_state=42)

"""# **3.Deep Learning Classification**

**Artificial Neural Network (ANN) Model**
"""

#Check the shapes of all X and y
X_train.shape, X_test.shape, y_train.shape, y_test.shape

#One-hot code your target variable using the to_categorical() function from the keras.utils module
from tensorflow.keras.utils import to_categorical
y_train_mlp = to_categorical(y_train, num_classes=12)
y_test_mlp = to_categorical(y_test, num_classes=12)
x_test_mlp = to_categorical(X_test, num_classes=12)
x_train_mlp = to_categorical(X_train, num_classes=12)

print(y_train_mlp.shape, y_test_mlp.shape,x_test_mlp.shape, x_train_mlp.shape)

#ANN Sequential Model
import time
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

#Start the model
model = Sequential()

#Set up the outter layer
model.add(Dense(264, activation='relu', input_dim=273))

# Dropout layers remove features and fight overfitting

model.add(Dense(264, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(64, activation='relu'))
model.add(Dense(32, activation='relu'))

# End with a number of units equal to the number of classes we have for our outcome
model.add(Dense(12, activation='softmax'))

#Model features
model.summary()

# Compile the model to put it all together.
model.compile(loss='categorical_crossentropy',optimizer= 'sgd',metrics=['accuracy'])

#Run the ANN model
model.fit(X_train, y_train_mlp,
                   epochs=40,
                  verbose=1,
                   batch_size=128)

#Evaluate the model
score = model.evaluate(X_test, y_test_mlp, verbose=1)

#Print results
print('Test loss:', score[0])
print('Test accuracy:', score[1])

#Predict the model
y_pred = model.predict(X_test)
y_pred_classes = (y_pred > 0.5).astype("int32")

# Compute accuracy score
accuracy = accuracy_score(y_test_mlp, y_pred_classes)
print("Accuracy:", accuracy)


# Generate classification report
report = classification_report(y_test_mlp, y_pred_classes)

# Print the report
print ("Classification Report")
print ("---------------------------------------------")
print(report)

"""**Convolutional Neural Network (CNN)**"""

#Convert the X_train to 3 dimension (No of rows, No of columns, No of single output row) for  CNN model
X_train_array = X_train.to_numpy()

# Reshape the array
X_train_resized = X_train_array.reshape(28039, 273,1)

# Print the resized array
print(X_train_resized)

#Convert the X_test to 3 dimension (No of rows, No of columns, No of single output row) for RNN and CNN models
x_test_array = X_test.to_numpy()

# Reshape the array
x_test_resized = x_test_array.reshape(12017, 273,1)

# Print the resized array
print(x_test_resized)

# 1D convolutional sequential model
from keras.layers import Dense, Conv1D, Flatten
model_cnn = Sequential()
model_cnn.add(Conv1D(32, 2, activation="relu", input_shape=(273, 1)))
model_cnn.add(Flatten())
model_cnn.add(Dense(64, activation="relu"))
model_cnn.add(Dense(1))
model_cnn.compile(loss="mse", optimizer="adam")

model_cnn.summary()

# Train the model
model_cnn.fit(X_train_resized, y_train, epochs=40, verbose=1, batch_size= 128)

#Predict the model
y_pred_cnn = model_cnn.predict(x_test_resized)
y_pred_classes_cnn = (y_pred_cnn ).astype("int32")

# Generate classification report
report = classification_report(y_test, y_pred_classes_cnn)

# Compute accuracy score
accuracy = accuracy_score(y_test, y_pred_classes_cnn)
print("Accuracy:", accuracy)

# Print the report
print ("Classification Report")
print ("---------------------------------------------")
print(report)

"""Based on the accuracy of ANN and CNN models, ANN model performed better than CNN

*   **ANN Model Accuracy - 78.3%** (6 Dense Layers, Ranging from 264 t0 12 neurons, 40 epoch, 128 batch size,loss='categorical_crossentropy',optimizer= 'sgd')
*   **CNN Model Accuracy - 48.6%** (1 Convolutional layer, 1 Dense layer, 40 epoch, 128 batch size, loss="mse", optimizer="adam")

# **4.Unsupervised Learning**

**PCA Feature Decomposition**
"""

#Drop unwanted columns
uns_final_dataset = final_dataset.drop(['timestamp','latitude','longitude','device_id'], axis = 1)

#Checking the dataset after dropping the columns
uns_final_dataset.head()

#One hot encoding for categorical columns
uns_final_dataset = pd.get_dummies(uns_final_dataset, columns = ['gender','age','group'], sparse = True).reset_index(drop= True)

#Duplicate the dataset for further analysis
uns_final_dataset_copy = uns_final_dataset
uns_final_dataset_gmm = uns_final_dataset

#Delete columns that are all zeros
uns_final_dataset = uns_final_dataset.drop(uns_final_dataset.columns[(uns_final_dataset == 0).all()], axis = 1)

#Print the first five rows of the new dataset
uns_final_dataset.head()

# Standardize features by removing the mean and scaling to unit variance with sklearns StandardScaler.
scaler = StandardScaler()

# Fit scaler to data by calling fit_transform on our data.
X_scale = scaler.fit_transform(uns_final_dataset)

# Storing scaled data into new DataFrame.
df_scale = pd.DataFrame(X_scale, columns=uns_final_dataset.columns)
df_scale.head()

# PCA with the number of components set to 2, this will reduce our data to two dimensions.
pca = PCA(n_components=2)

# We get the components by calling fit_transform method with our data.
pca_components = pca.fit_transform(df_scale)

# Defining pyplot figure size.
plt.figure(figsize=(10,5))

# Creating scatterplot of pca component dimensions with pyplot.
plt.scatter(pca_components[:, 0], pca_components[:, 1])
plt.xticks([])
plt.yticks([])
plt.axis('off')
plt.show()

# Components are now in Pandas DataFrame.
PCA_components = pd.DataFrame(pca_components)
# Create range of k values.
ks = range(1, 10)
inertias = []
for k in ks:
    # Create KMeans instance with k clusters: model.
    model = KMeans(n_clusters=k)

    # Fit model to samples.
    model.fit(PCA_components.iloc[:,:3])

    # Append the inertia to the list of inertias.
    inertias.append(model.inertia_)

plt.plot(ks, inertias, '-o', color='black')
plt.xlabel('number of clusters, k')
plt.ylabel('inertia')
plt.xticks(ks)
plt.show()

"""**Applying PCA to KMeans**"""

#Finding the silhouette score based on KMeans cluster value '3'
kmeans  = KMeans(n_clusters=3, random_state=123).fit(PCA_components)
y_pred = kmeans.predict(PCA_components)

# Print silhouette score of KMeans.
print (f'For Kmeans cluster number of 3')
print("silhouette_score is",metrics.silhouette_score(PCA_components, kmeans.labels_, metric='euclidean'))
plt.figure(figsize=(10,6))
plt.scatter(PCA_components[0],PCA_components[1], c=y_pred);
plt.show()

#Finding the silhouette score based on KMeans cluster value '4'
kmeans  = KMeans(n_clusters=4, random_state=123).fit(PCA_components)
y_pred = kmeans.predict(PCA_components)

# Print silhouette score of KMeans.
print (f'For Kmeans cluster number of 4')
print("silhouette_score is",metrics.silhouette_score(PCA_components, kmeans.labels_, metric='euclidean'))
plt.figure(figsize=(10,6))
plt.scatter(PCA_components[0],PCA_components[1], c=y_pred);
plt.show()

#Finding the silhouette score based on KMeans cluster value '5'
kmeans  = KMeans(n_clusters=5, random_state=123).fit(PCA_components)
y_pred = kmeans.predict(PCA_components)

# Print silhouette score of KMeans.
print (f'For Kmeans cluster number of 5')
print("silhouette_score is",metrics.silhouette_score(PCA_components, kmeans.labels_, metric='euclidean'))
plt.figure(figsize=(10,6))
plt.scatter(PCA_components[0],PCA_components[1], c=y_pred);
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Defining the k-means with the best silhouette value (4) and timing it.
kmeans_cluster = KMeans(n_clusters=4, random_state=123)
# Fitting and timing clustering.
# %timeit kmeans_cluster.fit(PCA_components)
y_pred = kmeans_cluster.predict(PCA_components)

"""**Cluster Analysis of KMeans Clusters using PCA**"""

#Adding the cluster info to the original dataset to do the analysis
uns_final_dataset_copy['clusters'] = kmeans_cluster.labels_
uns_final_dataset_copy['gender'] = final_dataset.gender
uns_final_dataset_copy['age'] = final_dataset.age
uns_final_dataset_copy['group'] = final_dataset.group

#Checking the dataset after adding the additional columns
uns_final_dataset_copy.head()

#Finding the cluster which have more records
ax = sns.countplot(x=uns_final_dataset_copy['clusters'],
                   order=uns_final_dataset_copy['clusters'].value_counts(ascending=False).index);

abs_values = uns_final_dataset_copy['clusters'].value_counts(ascending=False).values

ax.bar_label(container=ax.containers[0], labels=abs_values)

"""During the time of execution, the Cluster 1 have more number of records"""

#Finding the cluster which have most groups
plt.figure(figsize=(10,6))
sns.countplot(x ='group', data = uns_final_dataset_copy, hue= 'clusters')

"""During the time of execution,

*   the Cluster 0 have 'F27-F28', 'F29-32','F24-26','F33-42','F23-'. Only Female groups
*   the Cluster 1 have 'M39+', 'M32-38','M29-31','M29-31'. Only Male groups
*   the Cluster 2 have 'M22-', 'M27-28','M23-26','M29-31','M32-38' . Only Male groups
*   the Cluster 3 have 'F27-28', 'F29-32','F43+','F33-42 . Only Female groups


"""

#let's visualize the clusters formed by KMeans and PCA with a simple scatterplot.
plt.figure(figsize=(10,6))
plt.scatter(PCA_components[0],PCA_components[1], c=y_pred);
plt.show()

"""### **t-SNE Dimensionality Reduction**"""

#t-SNE Dimensionality Reduction with perplexity 90
import time
from sklearn.manifold import TSNE

perplexity = [90]

for i in perplexity:
    print ("perplexity is ",format(i))
    time_start = time.time()
    tsne = TSNE(n_components=2, verbose=1, perplexity=i, n_iter=1000)
    tsne_results = tsne.fit_transform(df_scale)

    print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))

    plt.figure(figsize=(10,5))
    plt.scatter(tsne_results[:, 0], tsne_results[:, 1])
    plt.xticks([])
    plt.yticks([])
    plt.axis('off')
    plt.show()

#Checking the t-SNE results
print(tsne_results)

"""**Applying tSNE to GMM**"""

# Finding the silhouette_score for GMM Cluster value 2
from sklearn.mixture import GaussianMixture
gmm_cluster = GaussianMixture(n_components=2, random_state=123)

# Fit model
clusters = gmm_cluster.fit_predict(tsne_results)


print (f'For GMM cluster number of 2')
print("The silhouette score of the GMM solution: {}"
      .format(metrics.silhouette_score(df_scale, clusters, metric='euclidean')))

plt.scatter(tsne_results[:, 0], tsne_results[:, 1], c=clusters);

# Finding the silhouette_score for GMM Cluster value 3
from sklearn.mixture import GaussianMixture
gmm_cluster = GaussianMixture(n_components=3, random_state=123)

# Fit model
clusters = gmm_cluster.fit_predict(tsne_results)


print (f'For GMM cluster number of 3')
print("The silhouette score of the GMM solution: {}"
      .format(metrics.silhouette_score(df_scale, clusters, metric='euclidean')))

plt.scatter(tsne_results[:, 0], tsne_results[:, 1], c=clusters);

# Finding the silhouette_score for GMM Cluster value 4
from sklearn.mixture import GaussianMixture
gmm_cluster = GaussianMixture(n_components=4, random_state=123)

# Fit model
clusters = gmm_cluster.fit_predict(tsne_results)


print (f'For GMM cluster number of 4')
print("The silhouette score of the GMM solution: {}"
      .format(metrics.silhouette_score(df_scale, clusters, metric='euclidean')))

plt.scatter(tsne_results[:, 0], tsne_results[:, 1], c=clusters);

# Finding the silhouette_score for GMM Cluster value 5
from sklearn.mixture import GaussianMixture
gmm_cluster = GaussianMixture(n_components=5, random_state=123)

# Fit model
clusters = gmm_cluster.fit_predict(tsne_results)


print (f'For GMM cluster number of 5')
print("The silhouette score of the GMM solution: {}"
      .format(metrics.silhouette_score(df_scale, clusters, metric='euclidean')))

plt.scatter(tsne_results[:, 0], tsne_results[:, 1], c=clusters);

# Finding the silhouette_score for GMM Cluster value 6
from sklearn.mixture import GaussianMixture
gmm_cluster = GaussianMixture(n_components=6, random_state=123)

# Fit model
clusters = gmm_cluster.fit_predict(tsne_results)


print (f'For GMM cluster number of 6')
print("The silhouette score of the GMM solution: {}"
      .format(metrics.silhouette_score(df_scale, clusters, metric='euclidean')))

plt.scatter(tsne_results[:, 0], tsne_results[:, 1], c=clusters);

"""Based on the silhouette score, the GMM Cluster value 2 looks better but running with 4 clusters to see more grouping"""

# Defining the GMM Model
from sklearn.mixture import GaussianMixture
gmm_cluster = GaussianMixture(n_components=4, random_state=123)

# Fit model
gmm_clusters = gmm_cluster.fit_predict(tsne_results)

print (f'For GMM cluster number of 4')
print("The silhouette score of the GMM solution: {}"
      .format(metrics.silhouette_score(df_scale, clusters, metric='euclidean')))

plt.scatter(tsne_results[:, 0], tsne_results[:, 1], c=clusters);

"""**Cluster Analysis of GMM Clusters using t-SNE**"""

#Adding the gmm cluster info into the original dataset
uns_final_dataset_gmm['clusters'] = gmm_clusters
uns_final_dataset_gmm['gender'] = final_dataset.gender
uns_final_dataset_gmm['age'] = final_dataset.age
uns_final_dataset_gmm['group'] = final_dataset.group

#Checking the dataset after adding the cluster info
uns_final_dataset_gmm.head()

#Finding the cluster which have more records
ax = sns.countplot(x=uns_final_dataset_gmm['clusters'],
                   order=uns_final_dataset_gmm['clusters'].value_counts(ascending=False).index);

abs_values = uns_final_dataset_gmm['clusters'].value_counts(ascending=False).values

ax.bar_label(container=ax.containers[0], labels=abs_values)

"""During the time of execution, the cluster 2 have more records"""

#Finding the cluster which have most groups
plt.figure(figsize=(10,6))
sns.countplot(x ='group', data = uns_final_dataset_gmm, hue= 'clusters')

"""During the time of execution,

*   Both Male and Female groups 'M22-','M39+','M27-28','F27-28','M32-38','M29-31','F29-32','F43+','F24-26','F33-42','F23-' are mapped to all the four clusters

# **5.Supervised Learning**

**Feature Selection through Kbest**

Running the Kbest for top 20 best features
"""

#Running Kbest for 20 top features
from sklearn.feature_selection import SelectKBest, f_classif

selector = SelectKBest(score_func=f_classif, k=20)

# Fit the selector to your data
selector.fit(X_processed, y)

# Get the indices of the selected features
selected_indices = selector.get_support(indices=True)

# Get the names of the selected features if you have them
selected_feature_names = [X_processed.columns[i] for i in selected_indices]

# Select the top 120 features from your data
X_selected = selector.transform(X_processed)

# If you want to see the scores of the selected features
selected_feature_scores = selector.scores_[selected_indices]

#Print the selected features
print (selected_feature_names)

#Create a dataframe with the new features
X_best_features = pd.DataFrame(X_processed, columns = selected_feature_names).reset_index(drop= True)

#Print information of the dataset
X_best_features.info()

#Function to get Classification Report, Confusion Matrix, F1 score and Cross Validation Score

def print_score(clf, X_train, y_train, X_test, y_test):
        pred = clf.predict(X_test)
        #Define the targets
        target_names = ['0.0', '1.0', '2.0', '3.0', '4.0', '5.0', '6.0', '7.0', '8.0', '9.0', '10.0', '11.0']

        #Print the classification report
        print(('Classification Report: \n {}\n').format(classification_report(y_test, pred,target_names=target_names)))

        #Calculate the confusion matrix
        confusion_rf = confusion_matrix(y_test, pred)

        #Print the confusion matrix
        print(('Confusion Matrix: \n\n {}\n\n').format(confusion_rf))

        #Print the overall accuracy
        print(('Model accuracy Score: {0:.2f} %\n').format(cross_val_score(clf,
                                                                              X_test,
                                                                              y_test, cv=kf).mean()*100))

#Split the dataset into a training and testing dataset 70/30
X_train_kbest, X_test_kbest, y_train_kbest, y_test_kbest = train_test_split(X_best_features, y,test_size=0.3, random_state=42)

#Random Forest Classification Model
rf = RandomForestClassifier()

#Tune hyperparameters
#Create range of values to fit parameters
n_estimators_param = np.arange(50,200,50)
max_depth_param = np.arange(1,20,5)

#Fit parameters
parameters = {'n_estimators': n_estimators_param, 'max_depth': max_depth_param}

#Fit parameters using gridsearch
rf = GridSearchCV(rf, param_grid=parameters,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
rf.fit(X_train_kbest, y_train_kbest)

#Print the best parameters
print(('Best paramenters Random Forest:\n {}\n').format(rf.best_params_))

#Once the model has been trained test it on the test dataset
rf.fit(X_test_kbest, y_test_kbest)

print_score(rf, X_train_kbest, y_train_kbest, X_test_kbest, y_test_kbest)

#Decision Tree Classification Model

dt = DecisionTreeClassifier()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = {'max_features': ['auto', 'sqrt', 'log2'],
              'ccp_alpha': [0.1, .01, .001],
              'max_depth' : np.arange(1,20,5),
              'criterion' :['gini', 'entropy']
             }

#Fit parameters using gridsearch
dt = GridSearchCV(dt, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
dt.fit(X_train_kbest, y_train_kbest)

#Print the best parameters
print(('Best paramenters Decision Tree Model:\n {}\n').format(dt.best_params_))

#Once the model has been trained test it on the test dataset
dt.fit(X_test_kbest, y_test_kbest)

print_score(dt, X_train_kbest, y_train_kbest, X_test_kbest, y_test_kbest)

#KNN Classification Model
from sklearn import neighbors

knn = neighbors.KNeighborsClassifier()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = { "weights": ["uniform", "distance"],
    "n_neighbors" : np.arange(1,40,5)
             }

#Fit parameters using gridsearch
knn = GridSearchCV(knn, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
knn.fit(X_train_kbest, y_train_kbest)

#Print the best parameters
print(('Best paramenters KNN model:\n {}\n').format(knn.best_params_))

#Once the model has been trained test it on the test dataset
knn.fit(X_test_kbest, y_test_kbest)

print_score(knn, X_train_kbest, y_train_kbest, X_test_kbest, y_test_kbest)

#Support Vector Classification Model

svc = SVC()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = { # "C": [0.001, 0.01, 0.1, 1.],
   "kernel": ["linear", "poly", "rbf", "sigmoid"],
  "gamma": ["scale", "auto"],
             }

#Fit parameters using gridsearch
svc = GridSearchCV(svc, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
svc.fit(X_train_kbest, y_train_kbest)

#Print the best parameters
print(('Best paramenters Support Vector:\n {}\n').format(svc.best_params_))

#Once the model has been trained test it on the test dataset
svc.fit(X_test_kbest, y_test_kbest)

print_score(svc, X_train_kbest, y_train_kbest, X_test_kbest, y_test_kbest)

#Logistic Classification Model
from sklearn.linear_model import LogisticRegression

lr = LogisticRegression()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = {  "C": [0.001, 0.01, 0.1, 1.],
    "penalty": ["l1", "l2"]
             }

#Fit parameters using gridsearch
lr = GridSearchCV(lr, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
lr.fit(X_train_kbest, y_train_kbest)

#Print the best parameters
print(('Best paramenters Logistic Classification:\n {}\n').format(lr.best_params_))

#Once the model has been trained test it on the test dataset
lr.fit(X_test_kbest, y_test_kbest)

print_score(lr, X_train_kbest, y_train_kbest, X_test_kbest, y_test_kbest)

"""**Feature Selection through PCA**

Running the PCA to get top 10 best features
"""

#Feature selection through PCA for top 10 features
sklearn_pca = PCA(n_components=10)
X_pca_10 = sklearn_pca.fit_transform(X_processed)
print(
    'The percentage of total variance in the dataset explained by each',
    'component from Sklearn PCA.\n',
    sklearn_pca.explained_variance_ratio_
)

#Split our dataset into train and test datasets
X_train_pca, X_test_pca, y_train_pca, y_test_pca = train_test_split(X_pca_10, y,
                                                    test_size=0.33, random_state=42, stratify= y)
print(X_train_pca.shape, y_train_pca.shape)
print(X_test_pca.shape, y_test_pca.shape)

#Random Forest Classification Model
rf_pca = RandomForestClassifier()

#Tune hyperparameters
#Create range of values to fit parameters
n_estimators_param = np.arange(50,200,50)
max_depth_param = np.arange(1,20,5)

#Fit parameters
parameters = {'n_estimators': n_estimators_param, 'max_depth': max_depth_param}

#Fit parameters using gridsearch
rf_pca = GridSearchCV(rf_pca, param_grid=parameters,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
rf_pca.fit(X_train_pca, y_train_pca)

#Print the best parameters
print(('Best paramenters Random Forest:\n {}\n').format(rf_pca.best_params_))

#Once the model has been trained test it on the test dataset
rf_pca.fit(X_test_pca, y_test_pca)

print_score(rf_pca, X_train_pca, y_train_pca, X_test_pca, y_test_pca)

#Decision Tree Classification Model

dt_pca = DecisionTreeClassifier()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = {'max_features': ['auto', 'sqrt', 'log2'],
              'ccp_alpha': [0.1, .01, .001],
              'max_depth' : np.arange(1,20,5),
              'criterion' :['gini', 'entropy']
             }

#Fit parameters using gridsearch
dt_pca = GridSearchCV(dt_pca, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
dt_pca.fit(X_train_pca, y_train_pca)

#Print the best parameters
print(('Best paramenters Decision Tree Model:\n {}\n').format(dt_pca.best_params_))

#Once the model has been trained test it on the test dataset
dt_pca.fit(X_test_pca, y_test_pca)

print_score(dt_pca, X_train_pca, y_train_pca, X_test_pca, y_test_pca)

#KNN Classification Model
from sklearn import neighbors

knn_pca = neighbors.KNeighborsClassifier()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = { "weights": ["uniform", "distance"],
    "n_neighbors" : np.arange(1,40,5)
             }

#Fit parameters using gridsearch
knn_pca = GridSearchCV(knn_pca, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
knn_pca.fit(X_train_pca, y_train_pca)

#Print the best parameters
print(('Best paramenters KNN model:\n {}\n').format(knn_pca.best_params_))

#Once the model has been trained test it on the test dataset
knn_pca.fit(X_test_pca, y_test_pca)

print_score(knn_pca, X_train_pca, y_train_pca, X_test_pca, y_test_pca)

#Support Vector Classification Model

svc_pca = SVC()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = { # "C": [0.001, 0.01, 0.1, 1.],
   "kernel": ["linear", "poly", "rbf", "sigmoid"],
  "gamma": ["scale", "auto"],
             }

#Fit parameters using gridsearch
svc_pca = GridSearchCV(svc_pca, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
svc_pca.fit(X_train_pca, y_train_pca)

#Print the best parameters
print(('Best paramenters Support Vector:\n {}\n').format(svc_pca.best_params_))

#Once the model has been trained test it on the test dataset
svc_pca.fit(X_test_pca, y_test_pca)

print_score(svc_pca, X_train_pca, y_train_pca, X_test_pca, y_test_pca)

#Logistic Classification Model
from sklearn.linear_model import LogisticRegression

lr_pca = LogisticRegression()

#Tune hyperparameters
#Create range of values to fit parameters

param_grid = {  "C": [0.001, 0.01, 0.1, 1.],
    "penalty": ["l1", "l2"]
             }

#Fit parameters using gridsearch
lr_pca = GridSearchCV(lr_pca, param_grid=param_grid,  n_jobs = -1, cv=kf, verbose = 1)

#Fit the tunned classifier in the training space
lr_pca.fit(X_train_pca, y_train_pca)

#Print the best parameters
print(('Best paramenters Logistic Classification:\n {}\n').format(lr_pca.best_params_))

#Once the model has been trained test it on the test dataset
lr_pca.fit(X_test_pca, y_test_pca)

lr_pca_predit = lr_pca.predict(X_test_pca)

print_score(lr_pca, X_train_pca, y_train_pca, X_test_pca, y_test_pca)

"""Comparing the Predictions of models based on Kbest Approach"""

predictions_dictionary_kbest = {'Actual': y_test_kbest,'Logistic Classification_Kbest' : lr.predict(X_test_kbest),
                          'KNN_Kbest' : knn.predict(X_test_kbest),
                          'SVC_Kbest' : svc.predict(X_test_kbest), 'Decision Tree_Kbest' : dt.predict(X_test_kbest) ,
                          'Random Forest_Kbest' : rf.predict(X_test_kbest)}

predictions_df_kbest = pd.DataFrame(predictions_dictionary_kbest)
predictions_df_kbest

"""Comparing the Predictions of models based on PCA Approach"""

predictions_dictionary_pca = {'Actual': y_test_pca,'Logistic Classification_pca' : lr_pca.predict(X_test_pca),
                          'KNN_pca' : knn_pca.predict(X_test_pca),
                          'SVC_pca' : svc_pca.predict(X_test_pca), 'Decision Tree_pca' : dt_pca.predict(X_test_pca) ,
                          'Random Forest_pca' : rf_pca.predict(X_test_pca)}

predictions_df_pca = pd.DataFrame(predictions_dictionary_pca)
predictions_df_pca

"""**Supervised Learning Models Accuarcy**

Model Accuracy through Kbest Approach (Top 20 Features):

1.   Logistic Classification - **74%** {'C': 1.0, 'penalty': 'l2'}
2.   KNN Classification - **91%** {'n_neighbors': 1, 'weights': 'uniform'}
3.   Decision Tree - **86%** {'ccp_alpha': 0.001, 'criterion': 'entropy', 'max_depth': 16, 'max_features': 'sqrt'}
4.   Support Vector Classification - **81%** {'gamma': 'scale', 'kernel': 'linear'}
5.   Random Forest - **97%** {'max_depth': 16, 'n_estimators': 150}

Model Accuracy through PCA:

1.   Logistic Classification - **54**% {'C': 1.0, 'penalty': 'l2'}
2.   KNN Classification - **92**% {'n_neighbors': 1, 'weights': 'uniform'}
3.   Decision Tree - **80**% {'ccp_alpha': 0.001, 'criterion': 'entropy', 'max_depth': 16, 'max_features': 'sqrt'}
4.   Support Vector Classification - **69**% {'gamma': 'scale', 'kernel': 'rbf'}
5.   Random Forest - **92**% {'max_depth': 16, 'n_estimators': 150}

# **6.Conclusion**

The purpose of this product is to classify a subset of the population of China that uses a mobile operator based on the apps they have installed and that they used and the brand of the device they have. The classification takes into consideration gender and age range. The groups are distributed as follows (M=male, F=female being digits age limits): 'M39+' , 'M32-38', 'M29-31', 'M27-28', 'M23-26', 'M22-', 'F43+' ,'F33-42', 'F29-32', 'F27-28', 'F24-26', 'F23-'.

**Exploratory data analysis:**

*   Number of apps active is roughly 50% of the apps installed
*   Population is concentrated in a range between 20 and 32 and that the age distribution
*   From an apps perspective, most of them have to do with financial products, banking and industrial (construction)
*   From a brand perspective eight brands represent 90% of the sample in the Chinese market (Xaomi, Samsung, Huawei, Vivo, OPPO, Meizu, Coldpad y Lenovo)
*   There is inequality in terms of gender distribution being the female users half the male users
*   The different groups are unbalanced therefore resampling of the data has been done to avoid bias on the different classifiers that are used

**Model Performance**

Model selection has been carried out splitting the sample into 70/30 training on 70% of the data. Models have been trained and tuned using gridsearch and cross validation with five folds has been used to test them.

**Supervised Learning Models:**

Model Accuracy through Kbest Approach (Top 20 Features):

*   Logistic Classification - 74% {'C': 1.0, 'penalty': 'l2'}
*   KNN Classification - 91% {'n_neighbors': 1, 'weights': 'uniform'}
*   Decision Tree - 86% {'ccp_alpha': 0.001, 'criterion': 'entropy', 'max_depth': 16, 'max_features': 'sqrt'}
*   Support Vector Classification - 81% {'gamma': 'scale', 'kernel': 'linear'}
*   Random Forest - 97% {'max_depth': 16, 'n_estimators': 150}

Model Accuracy through PCA:

*   Logistic Classification - 54% {'C': 1.0, 'penalty': 'l2'}
*   KNN Classification - 92% {'n_neighbors': 1, 'weights': 'uniform'}
*   Decision Tree - 80% {'ccp_alpha': 0.001, 'criterion': 'entropy', 'max_depth': 16, 'max_features': 'sqrt'}
*   Support Vector Classification - 69% {'gamma': 'scale', 'kernel': 'rbf'}
*   Random Forest - 92% {'max_depth': 16, 'n_estimators': 150}

**Deep Learning Models**

*   ANN Model Accuracy - 78.3% (6 Dense Layers, Ranging from 264 t0 12 neurons, 40 epoch, 128 batch size,loss='categorical_crossentropy',optimizer= 'sgd')
*   CNN Model Accuracy - 48.6% (1 Convolutional layer, 1 Dense layer, 40 epoch, 128 batch size, loss="mse", optimizer="adam")


**Hence, from a classification purpose the best model to use based on its accuracy is Random Forest which can compete in terms of accuracy with deep learning models but is a better candidate for production**
"""